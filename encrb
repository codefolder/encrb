#!/usr/bin/env python
# Copyright (c) 2012 Heikki Hokkanen <hoxu at users.sf.net>
# License: GPLv3
# encrb - encrypted remote backup
#
# Backs up plaintext local directories to remote machine as encrypted, using
# encfs --reverse and rsync
import optparse
import os
import random
import string
import subprocess
import sys
import time

class Encrb:
	def backup_path(self, path):
		print 'Backing up:', path
		tmpdir = subprocess.Popen(['mktemp', '-d'], stdout=subprocess.PIPE).communicate()[0].strip()

		# create encfs mount
		print 'Making encfs reverse mount...'
		env = dict(os.environ)
		env['ENCFS6_CONFIG'] = os.path.expanduser(self.options.keyfile)
		err = subprocess.call(['encfs', '--extpass', 'cat %s' % os.path.expanduser(self.options.passfile), '--reverse', path, tmpdir], env=env)

		# rsync
		if err == 0:
			try:
				destination = os.path.join(self.destination, path.strip('/').replace('/', '-'))
				print 'Rsyncing encrypted "%s" to "%s"...' % (path, destination)
				sys.stdout.flush()
				subprocess.call(['rsync', '-avzP', '--bwlimit', str(self.options.bwlimit), tmpdir + '/', destination])
			except KeyboardInterrupt, e:
				print 'KeyboardInterrupt, sleeping 1 sec, then unmounting'
				time.sleep(1)
				subprocess.call(['fusermount', '-u', tmpdir])
				subprocess.call(['rmdir', tmpdir])
				raise e
		else:
			print 'encfs returned error', err

		# Unmount
		print 'Unmounting encfs reverse mount...'
		subprocess.call(['fusermount', '-u', tmpdir])

		subprocess.call(['rmdir', tmpdir])

	def run(self):
		parser = optparse.OptionParser(usage='usage: %prog [options] dir-to-back-up1... remotepath')
		parser.add_option('-k', '--keyfile', dest='keyfile', default='~/.encfs6-encrb.xml', help='encfs keyfile to use [%default]')
		parser.add_option('-p', '--passfile', dest='passfile', default='~/.encfs-password', help='file containing encfs keyfile password [%default]')
		parser.add_option('-b', '--bwlimit', dest='bwlimit', default=0, type='int', help='Bandwidth limit (KiB/s) for rsync [%default]')

		(options, args) = parser.parse_args()
		self.options = options
		self.args = args
		self.options.keyfile = os.path.expanduser(self.options.keyfile)
		self.options.passfile = os.path.expanduser(self.options.passfile)
		print 'Options:', options

		if len(self.args) < 2:
			parser.error('Need more than two arguments')

		self.destination = self.args[-1]
		# TODO check that running new enough encfs (old has bugs in --reverse mode)
		print 'Paths to back up:', self.args[:-1]
		print 'Destination:', self.destination
		self.setup_once()
		for p in self.args[:-1]:
			self.backup_path(p)

	def setup_once(self):
		if os.path.exists(self.options.keyfile) or os.path.exists(self.options.passfile):
			return

		print '!!!!! Keyfile and passfile missing, running in setup mode. Press enter for default encfs settings.'

		# generate and save password
		password = ''.join(random.choice(string.letters + string.digits) for _ in range(10))
		f = open(self.options.passfile, 'w')
		f.write(password)
		f.close()

e = Encrb()
e.run()
