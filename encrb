#!/usr/bin/env python
# Copyright (c) 2012-2013 Heikki Hokkanen <hoxu at users.sf.net>
# Copyright (c) 2013 Andrius Sutas <git at motoko.sutas.eu>
# License: GPLv3
# encrb - encrypted remote backup
#
# Backs up plaintext local directories to remote machine as encrypted, using
# encfs --reverse and rsync
import optparse
import os
import random
import string
import subprocess
import commands
import sys
import tempfile
import time
import getpass
import re

def path_to_string(path):
    return path.strip('/').replace('/', '-')

class Encrb:
    def check_environment(self):
        required_tools = [('encfs', 1, 7, 3), ('sshfs', 0, 0, 0), ('rsync', 0, 0, 0), ('fusermount', 0, 0, 0)]
        
        for (required_cmd, required_major, required_minor, required_build) in required_tools:
            status, version = commands.getstatusoutput(required_cmd + " --version")

            # Check return value
            if (status != 0):
                raise Exception(required_cmd + " not found or crashed during version call...")
            
            # Consider only first "version" line
            version = version.split('\n')[0]

            # Look only for two or three numbers separated by dots
            version = str(re.search(r"\d\.\d(\.\d)?", version).group())

            # Parse version numbers
            version_numbers = version.split('.')
            version_major = int(version_numbers[0])
            version_minor = int(version_numbers[1])
            version_build = 0
            if (len(version_numbers) > 2):
                version_build = int(version_numbers[2])
            
            # Check version
            if ((version_major, version_minor, version_build) < (required_major, required_minor, required_build)):
                raise Exception(required_cmd + " must have version " + ".".join([str(required_major), str(required_minor), str(required_build)]) + " or higher, is: " + version)
                
            print required_cmd + " version: " + version

    def backup_path(self, path):
        print 'Backing up:', path
        friendlyname = path_to_string(path)
        tmpdir = tempfile.mkdtemp('-' + friendlyname)

        # Construct rsync params
        rsync_parameters = ['-avz', '--partial', '--progress', '--bwlimit', str(self.options.bwlimit)]
        try:
            for e in self.exclude_paths:
                rsync_parameters.append('--exclude=' + e)
        except:
            pass

        if (self.options.rsync_delete):
            rsync_parameters += ['--delete', '--delete-excluded']

        # create encfs mount
        print 'Making encfs reverse mount to "%s"...' % tmpdir
        env = self.get_modified_env()
        err = subprocess.call(['encfs', '--extpass', 'cat %s' % os.path.expanduser(self.options.passfile), '--reverse', path, tmpdir], env=env)

        # rsync
        if err == 0:
            try:
                destination = os.path.join(self.destination, friendlyname)
                print 'Rsyncing encrypted "%s" to "%s"...' % (path, destination)
                sys.stdout.flush()
                subprocess.call(['rsync'] + rsync_parameters + [tmpdir + '/', destination])
            except KeyboardInterrupt, e:
                print 'KeyboardInterrupt, sleeping 1 sec, then unmounting'
                time.sleep(1)
                subprocess.call(['fusermount', '-u', tmpdir])
                os.rmdir(tmpdir)
                raise e
        else:
            print 'encfs returned error', err

        # Unmount
        print 'Unmounting encfs reverse mount...'
        subprocess.call(['fusermount', '-u', tmpdir])

        os.rmdir(tmpdir)

    def backup_keyfile(self):
        try:
            print 'Rsyncing Encfs keyfile to "%s"...' % (self.destination)
            sys.stdout.flush()
            subprocess.call(['rsync', '-avz', '--progress', '--bwlimit', str(self.options.bwlimit), self.options.keyfile, self.destination])
        except e:
            #print 'KeyboardInterrupt...'
            time.sleep(1)
            raise e

    def get_modified_env(self):
        env = dict(os.environ)
        env['ENCFS6_CONFIG'] = os.path.expanduser(self.options.keyfile)
        return env

    def verify_path(self, path):
        print 'Verifying:', path

        # create sshfs mount
        friendlyname = path_to_string(path)
        mountpath = os.path.join(self.destination, friendlyname)
        tmpdir = tempfile.mkdtemp('-' + friendlyname)
        tmpdirplain = tempfile.mkdtemp('-%s-plain' % friendlyname)
        print 'Mounting "%s" sshfs read-only to "%s"...' % (mountpath, tmpdir)
        try:
            subprocess.check_call(['sshfs', '-o', 'ro', mountpath, tmpdir])

            # create encfs mount
            print 'Mounting encfs on "%s"...' % tmpdirplain
            try:
                env = self.get_modified_env()
                subprocess.call(['encfs', '--extpass', 'cat %s' % os.path.expanduser(self.options.passfile), tmpdir, tmpdirplain], env=env)

                # compare files
                print 'Running rsync --dry-run, this should not list any changes...'
                subprocess.call(['rsync', '-a', '--dry-run', path, tmpdirplain])

            finally:
                # wait a bit, or unmounting fails
                print 'Sleeping a bit...'
                time.sleep(5)

                # umount encfs
                print 'Unmounting encfs "%s...' % tmpdirplain
                subprocess.call(['fusermount', '-u', tmpdirplain])

        finally:
            # umount sshfs
            print 'Unmounting sshfs "%s"...' % tmpdir
            subprocess.call(['fusermount', '-u', tmpdir])
            os.rmdir(tmpdirplain)
            os.rmdir(tmpdir)

    def get_exclude_paths(self):
        exclude_paths = []

        # Check if file has been specified
        if (self.options.exclude_from == ''):
            return exclude_paths

        f = open(self.options.exclude_from, "r")

        print 'Generating exclude path list...'
        for backup_path in self.args[:-1]:
            for exclude_dir in f:
                exclude_dir = exclude_dir.strip()
                
                if (exclude_dir != '' and exclude_dir[0] != '#'):
                    try:
                        # Encode path names without mounting
                        env = self.get_modified_env()
                        output = subprocess.check_output(['encfsctl', 'encode', '--extpass', 'cat %s' % os.path.expanduser(self.options.passfile), backup_path, exclude_dir], env=env)
                    
                        for exclude in iter(output.splitlines()):
                            exclude_paths.append(exclude)

                    except e:
                        raise e

        f.close()
        return exclude_paths

    def run(self):
        parser = optparse.OptionParser(usage='usage: %prog [options] dir-to-back-up1... remotepath')
        parser.add_option('-k', '--keyfile', dest='keyfile', default='~/.encrb/encfs.xml', help='encfs keyfile to use [%default]')
        parser.add_option('-p', '--passfile', dest='passfile', default='~/.encrb/password', help='file containing encfs keyfile password [%default]')
        parser.add_option('-b', '--bwlimit', dest='bwlimit', default=0, type='int', help='Bandwidth limit (KiB/s) for rsync [%default]')
        parser.add_option('-v', '--verify', dest='verify', default=False, action="store_true", help="Instead of backing up, verify that the backups match sources")
        parser.add_option('', '--backup-keyfile', dest='backup_keyfile', default=False, action="store_true", help="Backup Encfs keyfile on remote machine - NOT RECOMMENDED")
        parser.add_option('', '--no-env-check', dest='check_env', default=True, action="store_false", help="Disable environment tool version checking")
        parser.add_option('-e', '--exclude-from', dest='exclude_from', default='', help='Read rsync exclude patterns from file')
        parser.add_option('', '--no-delete', dest='rsync_delete', default=True, action="store_false", help="Do not delete existing remote files that are no longer present locally or have been excluded")


        (options, args) = parser.parse_args()
        self.options = options
        self.args = args
        self.options.keyfile = os.path.expanduser(self.options.keyfile)
        self.options.passfile = os.path.expanduser(self.options.passfile)
        self.options.exclude_from = os.path.expanduser(self.options.exclude_from)
        print 'Options:', options

        if (self.options.check_env):
            self.check_environment()

        if len(self.args) < 2:
            parser.error('Need more than two arguments')

        self.destination = self.args[-1]
        print 'Paths to back up:', self.args[:-1]
        print 'Destination:', self.destination

        self.setup_once()

        if (options.backup_keyfile):
            self.backup_keyfile()
        
        self.exclude_paths = self.get_exclude_paths()

        for p in self.args[:-1]:
            if options.verify:
                self.verify_path(p)
            else:
                self.backup_path(p)

    def setup_once(self):
        if (not os.path.exists(self.options.passfile)):
            print '!!!!! Passfile missing, running in setup mode. Press enter for default encfs settings.'

            # Ensure passfile leaf and parent dirs are present,
            # otherwise open() will fail
            fdir = os.path.dirname(self.options.keyfile)
            if not os.path.exists(fdir):
                os.makedirs(fdir)
        
            # Ask or generate and save password
            password = getpass.getpass(prompt='Encfs encryption password (enter for random): ')
            if (password == ''):
                print "No password given, generating random one..."
                password = ''.join(random.choice(string.letters + string.digits) for _ in range(20))
        
            f = open(self.options.passfile, 'w')
            f.write(password)
            f.close()

        if (not os.path.exists(self.options.keyfile)):
            print '!!!!! keyfile missing, running in setup mode. Press enter for default encfs settings.'

            # Mount in reverse mode on arbitrary directory,
            # as this seems to be the only way to generate config
            tmpdir = tempfile.mkdtemp('-encfs-first')
            tmpdirplain = tempfile.mkdtemp('-encfs-first-plain')
            try:
                print "Mounting encfs for first time..."
                env = self.get_modified_env()
                subprocess.call(['encfs', '--extpass', 'cat %s' % os.path.expanduser(self.options.passfile), '--reverse', tmpdir, tmpdirplain], env=env)
            finally:
                print 'Unmounting encfs "%s...' % tmpdirplain
                subprocess.call(['fusermount', '-u', tmpdirplain])

e = Encrb()
e.run()
